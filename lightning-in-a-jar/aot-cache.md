## What's in the Cache?! 

![](images/whats-in-the-box.png)

VV

##### JVM level:

* **Class loading, linking,** and initialization
	* **Reading classes from disk**
	* **Classfile validation and metadata construction**
	* Running static initializers
* Interpretation
* **Callsite linkage, constant pool resolution**
* **Profile gathering**
* JIT Optimizations

##### Application level: 

* Reading config files
* Scanning for annotations
* Opening sockets, registering listeners
* Creating loggers

VV

## Demo!

VV

## Advantages

✅ Preserves Java's dynamism 
<br/>
✅ Platform independent
<br/>
✅ Still have full JVM and JIT to fall back on

VV

## Java's Dynamism 

* Dynamic typing (array store checks, casting)
* Dynamic class loading and verification
* Dynamic class redefinition
* Dynamic compilation (JITting)
* Dynamic recompilation (deoptimization)
* Dynamic linkage and access control
* Dynamic dispatch (virtual methods)
* Dynamic introspection (instanceof, reflection)

VV

## Extra Work

⚙️ How to perform the training runs? <br/>
⚙️ Where to store the cache? <br/>



VV

## Building the Cache?


![](images/graphs/Slide4.png)

VV

## Where to Build the Cache?


![](images/graphs/Slide5.png)

VV

## Where to Build the Cache?


![](images/graphs/Slide6.png)



VV

## Where's the Cache?


![](images/graphs/Slide7.png)


VV

## Where's the Cache?


![](images/graphs/Slide8.png)



VV
	
## Demo part deux!



